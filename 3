use std::{fmt::Display, str::FromStr};

use anyhow::anyhow;

advent_of_code::solution!(25);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Register {
    A,
    B,
    C,
    D,
}

impl FromStr for Register {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "a" => Ok(Self::A),
            "b" => Ok(Self::B),
            "c" => Ok(Self::C),
            "d" => Ok(Self::D),
            _ => Err(anyhow!("{s} is not a valid register")),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Value {
    Reg(Register),
    Imm(isize),
}

impl FromStr for Value {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Ok(r) = s.parse() {
            Ok(Self::Reg(r))
        } else if let Ok(i) = s.parse() {
            Ok(Self::Imm(i))
        } else {
            Err(anyhow!("{s} is not a valid value"))
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Instruction {
    Cpy(Value, Register),
    Inc(Register),
    Dec(Register),
    Jnz(Value, Value),
    Out(Register),
}

#[derive(Debug)]
enum InstError {
    AnyErr(anyhow::Error),
    Nop,
}

impl Display for InstError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            InstError::AnyErr(e) => write!(f, "{e}"),
            InstError::Nop => write!(f, "instruction is a nop"),
        }
    }
}

impl std::error::Error for InstError {};

impl FromStr for Instruction {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {}
}

pub fn part_one(input: &str) -> Option<u32> {
    None
}

pub fn part_two(input: &str) -> Option<u32> {
    None
}
